options {
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(SmallTalkLexer)
package lexical;

public class SmallTalkLexer {
  public static void main(String[] args) throws ParseException {
    SmallTalkLexer lexer;
    if (args.length == 0) {
      System.out.println("Smalltalk Lexical Analyzer: Reading from standard input...");
      lexer = new SmallTalkLexer(System.in);
    } else if (args.length == 1) {
      System.out.println("Smalltalk Lexical Analyzer: Reading from file " + args[0]);
      System.out.println("----------------------------------------------------------------");
      try {
        lexer = new SmallTalkLexer(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Smalltalk Lexical Analyzer: Usage is one of:");
      System.out.println("         java SmallTalkLexer < inputfile");
      System.out.println("OR");
      System.out.println("         java SmallTalkLexer inputfile");
      return;
    }

    try {
      lexer.Start();
    } catch (ParseException e) {
      System.out.println("Syntax Error: " + e.getMessage());
    }
    System.out.println("----------------------------------------------------------------");
  }
}

PARSER_END(SmallTalkLexer)

// Ignorando espaços em branco e comentários
// separator ::= (whitespace | comment)*
SKIP : {
  < TOKEN_white_space: " " >
  | < TOKEN_horizontal_tab: "\t" >
  | < TOKEN_new_line: "\n" >
  | < TOKEN_carriage_return: "\r" >
  | < TOKEN_comment: "\"" (~["\""] | "\"\"")* "\"" > // Comentários com qualquer caractere que não seja aspas
}

/**
* Definição dos tokens
*
* OBS: A ordem dos tokens foram definidos conforme o documento base.
*/
TOKEN : {

// 1) Identificadores reservados (ou palavras reservadas)
    < TOKEN_nil: "nil" >
    | < TOKEN_true: "true" >
    | < TOKEN_false: "false" >
    | < TOKEN_self: "self" >
    | < TOKEN_super: "super" >

// 2) Definição das categorias de caracteres (conforme seção 3.5.1)
    // Dígitos
    | < TOKEN_digit: ["0"-"9"] >

    // Letras maiúsculas do alfabeto inglês
    | < TOKEN_uppercase_alphabetic: ["A"-"Z"] >

    // Letras minúsculas do alfabeto inglês
    | < TOKEN_lowercase_alphabetic: ["a"-"z"] >

    // Letra não-case sensitive (underscore)
    | < TOKEN_non_case_letter: "_" >

    // Definição de letra conforme a especificação
    | < TOKEN_letter: <TOKEN_uppercase_alphabetic> | <TOKEN_lowercase_alphabetic> | <TOKEN_non_case_letter> >

// 3) Definição de identificador conforme seção 3.5.3:
    // identifier ::= letter (letter | digit)*
    | < TOKEN_identifier: <TOKEN_letter> (<TOKEN_letter> | <TOKEN_digit>)* >

// 4) Definição de keywords conforme seção 3.5.4:
    // keyword ::= identifier ':'
    | < TOKEN_keyword: <TOKEN_identifier> ":" >

// Símbolos de pontuação básicos
    | < TOKEN_colon: ":" >
    | < TOKEN_hash: "#" >

// 5) Definição dos operadores conforme seção 3.5.5
  // Binary Selector: um ou mais binary characters
  // Conforme a especificação: binarySelector ::= binaryCharacter+
  | < TOKEN_binary_selector: (["+", "-", "*", "/", "\\", "~", "<", ">", "=", "@", "%", "|", "&", "?", "!"])+ >

  // 3. Return Operator
  | < TOKEN_return_operator: "^" >

  // 4. Assignment Operator
  | < TOKEN_assignment_operator: ":=" >

// 6) Definição de números conforme seção 3.5.6

  // 1. Decimal Integer: sequência de dígitos
  | < TOKEN_decimal_integer: (["0"-"9"])+ >

  // 2. Radix Integer: [radixSpecifier]r[radixDigits]
  // radixSpecifier é um número entre 2-36 e radixDigits são dígitos válidos naquela base
  | < TOKEN_radix_integer: (["0"-"9"])+ ["r", "R"] (["0"-"9", "A"-"Z"])+ >

  // 3. Float: mantissa [exponentLetter exponent]
  // mantissa ::= digits '.' digits
  // exponent ::= ['-']decimalInteger
  // exponentLetter ::= 'e' | 'd' | 'q'
  | < TOKEN_float: (["0"-"9"])+ "." (["0"-"9"])+ (["e", "E", "d", "D", "q", "Q"] (["-"])? (["0"-"9"])+)? >

  // 4. Scaled Decimal conforme a definição completa:
  // scaledDecimal ::= scaledMantissa 's' [fractionalDigits]
  // scaledMantissa ::= decimalInteger | mantissa
  // fractionalDigits ::= decimalInteger
  //
  // Exemplo: 123s (sem dígitos fracionais) = 123s0
  // Exemplo: 123.0s (sem dígitos fracionais explícitos) = 123s1 = 123.0s1
  // Exemplo: 123.000s (sem dígitos fracionais explícitos) = 123s3 = 123.0s3
  | < TOKEN_scaled_decimal:
        // Forma 1: número inteiro seguido por 's' e opcionalmente um inteiro para precisão
        (["0"-"9"])+ "s" (["0"-"9"])* |

        // Forma 2: número com ponto decimal seguido por 's' e opcionalmente um inteiro para precisão
        (["0"-"9"])+ "." (["0"-"9"])+ "s" (["0"-"9"])*
    >

// 5) Quoted Character conforme seção 3.5.7:
  // quotedCharacter ::= '$' character
  // Um caractere entre aspas é um cifrão ($) seguido por qualquer caractere único
  | < TOKEN_quoted_character: "$" (~[]) >

// 6) Quoted String conforme seção 3.5.8:
  // quotedString ::= stringDelimiter stringBody stringDelimiter
  // stringBody ::= (nonStringDelimiter | (stringDelimiter stringDelimiter)*)
  // stringDelimiter ::= "'" (uma aspas simples)
  // nonStringDelimiter ::= "qualquer caractere exceto stringDelimiter"
  | < TOKEN_quoted_string: "'" ( ~["'"] | "''" )* "'" >

// 7) Hashed String conforme seção 3.5.9:
  // hashedString ::= '#' quotedString
  | < TOKEN_hashed_string: "#" "'" ( ~["'"] | "''" )* "'" >

// 8) Quoted Selector conforme seção 3.5.10:
  // quotedSelector ::= '#' (unarySelector | binarySelector | keywordSelector)
  // - Um seletor unário precedido por # (exemplo: #size, #name)
  | < TOKEN_quoted_unary_selector: "#" <TOKEN_identifier> >

  // - Um seletor binário precedido por # (exemplo: #+, #-, #*)
  | < TOKEN_quoted_binary_selector: "#" (["+", "-", "*", "/", "\\", "~", "<", ">", "=", "@", "%", "|", "&", "?", "!"])+ >

  // - Um seletor de palavra-chave precedido por # (exemplo: #at:put:, #do:)
  | < TOKEN_quoted_keyword_selector: "#" <TOKEN_identifier> ":" ( <TOKEN_identifier> ":" )* >
}

// Análise léxica principal
void Start() :
{}
{
  (Token())* <EOF>
}

void Token() :
{
  Token t;
}
{
////
    t = <TOKEN_nil> { System.out.println("TOKEN_nil " + t.image); } |
    t = <TOKEN_true> { System.out.println("TOKEN_true " + t.image); } |
    t = <TOKEN_false> { System.out.println("TOKEN_false " + t.image); } |
    t = <TOKEN_self> { System.out.println("TOKEN_self " + t.image); } |
    t = <TOKEN_super> { System.out.println("TOKEN_super " + t.image); }
////
    t = <TOKEN_digit> { System.out.println("TOKEN_digit " + t.image); } |
    t = <TOKEN_uppercase_alphabetic> { System.out.println("TOKEN_uppercase_alphabetic " + t.image); } |
    t = <TOKEN_lowercase_alphabetic> { System.out.println("TOKEN_lowercase_alphabetic " + t.image); } |
    t = <TOKEN_non_case_letter> { System.out.println("TOKEN_non_case_letter " + t.image); } |
    t = <TOKEN_letter> { System.out.println("TOKEN_letter " + t.image); } |
////
    t = <TOKEN_identifier> { System.out.println("TOKEN_identifier " + t.image); } |
////
    t = <TOKEN_keyword> { System.out.println("TOKEN_keyword " + t.image); } |
////
    t = <TOKEN_colon> { System.out.println("TOKEN_colon " + t.image); } |
    t = <TOKEN_hash> { System.out.println("TOKEN_hash " + t.image); } |
////
    t = <TOKEN_binary_selector> { System.out.println("TOKEN_binary_selector " + t.image); } |
    t = <TOKEN_return_operator> { System.out.println("TOKEN_return_operator " + t.image); } |
    t = <TOKEN_assignment_operator> { System.out.println("TOKEN_assignment_operator " + t.image); } |
////
    t = <TOKEN_decimal_integer> { System.out.println("TOKEN_decimal_integer " + t.image); } |
    t = <TOKEN_radix_integer> { System.out.println("TOKEN_radix_integer " + t.image); } |
    t = <TOKEN_float> { System.out.println("TOKEN_float " + t.image); } |
    t = <TOKEN_scaled_decimal> { System.out.println("TOKEN_scaled_decimal " + t.image); } |
////
    t = <TOKEN_quoted_character> { System.out.println("TOKEN_quoted_character " + t.image); } |
////
    t = <TOKEN_quoted_string> { System.out.println("TOKEN_quoted_string " + t.image); } |
////
    t = <TOKEN_hashed_string> { System.out.println("TOKEN_hashed_string " + t.image); } |
////
    t = <TOKEN_quoted_unary_selector> { System.out.println("TOKEN_quoted_unary_selector " + t.image); } |
    t = <TOKEN_quoted_binary_selector> { System.out.println("TOKEN_quoted_binary_selector " + t.image); } |
    t = <TOKEN_quoted_keyword_selector> { System.out.println("TOKEN_quoted_keyword_selector " + t.image); }
////
}
